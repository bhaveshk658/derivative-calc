import math
import operator
import queue
import re

from .tree import (
    SumNode,
    DifferenceNode, 
    ProductNode, 
    DivideNode, 
    PowerNode, 
    XNode, 
    ConstantNode
)

from sympy.parsing.sympy_parser import parse_expr

def precedence(operator):
    '''
    Determines the precedence for mathematical operators.
    '''
    if operator == '+' or operator == '-':
        return 2
    elif operator == '*' or operator == '/':
        return 3
    elif operator == '^':
        return 4
    elif operator in functions:
        return 5
    return 1

special_chars = {'e', 'pi', 'x'}

operators = {'+': operator.add,
             '-': operator.sub,
             '*': operator.mul,
             '/': operator.truediv,
             '^': operator.pow}

left_operators = {'+': operator.add,
                  '-': operator.sub,
                  '*': operator.mul,
                  '/': operator.truediv}

functions = {'sin': math.sin,
             'cos': math.cos,
             'tan': math.tan}

def shunting_yard(expression):
    '''
    Shunting-yard algorithm, taking in an infix expression
    and returning a queue in Reverse Polish notation.
    Arguments: Mathematical expression (string)
    Returns: Queue, with elements in RPN
    '''
    ops = []
    output = queue.Queue()

    i = 0
    while i < len(expression):
        token = expression[i]

        if token.isalpha():
            function = ''
            while (i < len(expression) and expression[i].isalpha()):
                function += expression[i]
                i += 1
            if function in functions:
                ops.append(function)
            elif function in special_chars:
                output.put(function)
            continue
            
        
        elif token.isdigit():
            num = ''
            while (i < len(expression) and expression[i].isdigit()):
                num += expression[i]
                i += 1
            output.put(num)
            continue

        elif token in operators:
            while ((len(ops) != 0)
                and ((precedence(ops[-1]) > precedence(token))
                    or (precedence(ops[-1]) == precedence(token) and token in left_operators))
                and (ops[-1] != '(')):
                output.put(ops.pop())
            ops.append(token)

        elif token == '(':
            ops.append(token)
        
        elif token == ')':
            while len(ops) != 0 and ops[-1] != '(':
                output.put(ops.pop())
            if ops[-1] == '(':
                ops.pop()
        i += 1

    if i == len(expression):
        while len(ops) != 0:
            output.put(ops.pop())
    
    return output


def rpn_to_tree(q):
    '''
    Converts queue generated by Shunting-yard algorithm
    to an Abstract Syntax Tree. 
    Arguments: Queue, with elements in RPN
    Returns: Root node of expression tree.
    '''
    nodes = []

    while not q.empty():
        token = q.get()
        if token == '+':
            node = SumNode()
        elif token == '-':
            node = DifferenceNode()
        elif token == '*':
            node = ProductNode()
        elif token == '/':
            node = DivideNode()
        elif token == 'x':
            node = XNode()
        elif token == '^':
            node = PowerNode()
        else:
            node = ConstantNode(token)
        if token in operators or token in functions:
            if len(nodes) != 0:
                node1 = nodes.pop()
                node.right = node1
            if len(nodes) != 0 and token not in functions:
                node2 = nodes.pop()
                node.left = node2
            
            nodes.append(node)
        else:
            nodes.append(node)

    return nodes[0]

def tree_to_infix(node):
    '''
    Converts the tree represented by the given node into an infix expression.
    Infix traversal from Wikipedia, BETs.
    Arguments: Root node of expression tree.
    Returns: Infix expression, string.
    '''

    infix = ''
    if node:
        if node.val in operators:
            infix += '('
        infix += tree_to_infix(node.left)
        infix += node.val
        infix += tree_to_infix(node.right)
        if node.val in operators:
            infix += ')'
    
    return infix

def simplify(expression):
    '''
    Simplifies expression using sympy for readability. Next steps: eliminate
    the need for sympy's shortcut.
    Arguments: String expression
    Returns: Simplified string expression
    '''
    expression = expression.replace('^', '**')
    return str(parse_expr(expression, evaluate=True))

def derivate(expr):
    q =  shunting_yard(expr)
    root = rpn_to_tree(q)
    d = root.derivate()
    infix = tree_to_infix(d)
    simplified = simplify(infix)
    simplified = simplified.replace('**', '^')
    return simplified






